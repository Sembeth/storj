// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pointerdb.proto

package fastpb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type RedundancyScheme_SchemeType int32

const (
	RedundancyScheme_INVALID RedundancyScheme_SchemeType = 0
	RedundancyScheme_RS      RedundancyScheme_SchemeType = 1
)

var RedundancyScheme_SchemeType_name = map[int32]string{
	0: "INVALID",
	1: "RS",
}

var RedundancyScheme_SchemeType_value = map[string]int32{
	"INVALID": 0,
	"RS":      1,
}

func (x RedundancyScheme_SchemeType) String() string {
	return proto.EnumName(RedundancyScheme_SchemeType_name, int32(x))
}

func (RedundancyScheme_SchemeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_75fef806d28fc810, []int{0, 0}
}

type Pointer_DataType int32

const (
	Pointer_INLINE Pointer_DataType = 0
	Pointer_REMOTE Pointer_DataType = 1
)

var Pointer_DataType_name = map[int32]string{
	0: "INLINE",
	1: "REMOTE",
}

var Pointer_DataType_value = map[string]int32{
	"INLINE": 0,
	"REMOTE": 1,
}

func (x Pointer_DataType) String() string {
	return proto.EnumName(Pointer_DataType_name, int32(x))
}

func (Pointer_DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_75fef806d28fc810, []int{3, 0}
}

type RedundancyScheme struct {
	Type RedundancyScheme_SchemeType `protobuf:"varint,1,opt,name=type,proto3,enum=fastpb.RedundancyScheme_SchemeType" json:"type,omitempty"`
	// these values apply to RS encoding
	MinReq           int32 `protobuf:"varint,2,opt,name=min_req,json=minReq,proto3" json:"min_req,omitempty"`
	Total            int32 `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
	RepairThreshold  int32 `protobuf:"varint,4,opt,name=repair_threshold,json=repairThreshold,proto3" json:"repair_threshold,omitempty"`
	SuccessThreshold int32 `protobuf:"varint,5,opt,name=success_threshold,json=successThreshold,proto3" json:"success_threshold,omitempty"`
	ErasureShareSize int32 `protobuf:"varint,6,opt,name=erasure_share_size,json=erasureShareSize,proto3" json:"erasure_share_size,omitempty"`
}

func (m *RedundancyScheme) Reset()         { *m = RedundancyScheme{} }
func (m *RedundancyScheme) String() string { return proto.CompactTextString(m) }
func (*RedundancyScheme) ProtoMessage()    {}
func (*RedundancyScheme) Descriptor() ([]byte, []int) {
	return fileDescriptor_75fef806d28fc810, []int{0}
}
func (m *RedundancyScheme) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedundancyScheme) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedundancyScheme.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedundancyScheme) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedundancyScheme.Merge(m, src)
}
func (m *RedundancyScheme) XXX_Size() int {
	return m.Size()
}
func (m *RedundancyScheme) XXX_DiscardUnknown() {
	xxx_messageInfo_RedundancyScheme.DiscardUnknown(m)
}

var xxx_messageInfo_RedundancyScheme proto.InternalMessageInfo

func (m *RedundancyScheme) GetType() RedundancyScheme_SchemeType {
	if m != nil {
		return m.Type
	}
	return RedundancyScheme_INVALID
}

func (m *RedundancyScheme) GetMinReq() int32 {
	if m != nil {
		return m.MinReq
	}
	return 0
}

func (m *RedundancyScheme) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *RedundancyScheme) GetRepairThreshold() int32 {
	if m != nil {
		return m.RepairThreshold
	}
	return 0
}

func (m *RedundancyScheme) GetSuccessThreshold() int32 {
	if m != nil {
		return m.SuccessThreshold
	}
	return 0
}

func (m *RedundancyScheme) GetErasureShareSize() int32 {
	if m != nil {
		return m.ErasureShareSize
	}
	return 0
}

type RemotePiece struct {
	PieceNum int32  `protobuf:"varint,1,opt,name=piece_num,json=pieceNum,proto3" json:"piece_num,omitempty"`
	NodeId   NodeID `protobuf:"bytes,2,opt,name=node_id,json=nodeId,proto3,customtype=NodeID" json:"node_id"`
}

func (m *RemotePiece) Reset()         { *m = RemotePiece{} }
func (m *RemotePiece) String() string { return proto.CompactTextString(m) }
func (*RemotePiece) ProtoMessage()    {}
func (*RemotePiece) Descriptor() ([]byte, []int) {
	return fileDescriptor_75fef806d28fc810, []int{1}
}
func (m *RemotePiece) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemotePiece) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemotePiece.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemotePiece) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemotePiece.Merge(m, src)
}
func (m *RemotePiece) XXX_Size() int {
	return m.Size()
}
func (m *RemotePiece) XXX_DiscardUnknown() {
	xxx_messageInfo_RemotePiece.DiscardUnknown(m)
}

var xxx_messageInfo_RemotePiece proto.InternalMessageInfo

func (m *RemotePiece) GetPieceNum() int32 {
	if m != nil {
		return m.PieceNum
	}
	return 0
}

type RemoteSegment struct {
	Redundancy   *RedundancyScheme `protobuf:"bytes,1,opt,name=redundancy,proto3" json:"redundancy,omitempty"`
	RootPieceId  PieceID           `protobuf:"bytes,2,opt,name=root_piece_id,json=rootPieceId,proto3,customtype=PieceID" json:"root_piece_id"`
	RemotePieces []RemotePiece     `protobuf:"bytes,3,rep,name=remote_pieces,json=remotePieces,proto3" json:"remote_pieces"`
}

func (m *RemoteSegment) Reset()         { *m = RemoteSegment{} }
func (m *RemoteSegment) String() string { return proto.CompactTextString(m) }
func (*RemoteSegment) ProtoMessage()    {}
func (*RemoteSegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_75fef806d28fc810, []int{2}
}
func (m *RemoteSegment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteSegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteSegment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteSegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteSegment.Merge(m, src)
}
func (m *RemoteSegment) XXX_Size() int {
	return m.Size()
}
func (m *RemoteSegment) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteSegment.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteSegment proto.InternalMessageInfo

func (m *RemoteSegment) GetRedundancy() *RedundancyScheme {
	if m != nil {
		return m.Redundancy
	}
	return nil
}

func (m *RemoteSegment) GetRemotePieces() []RemotePiece {
	if m != nil {
		return m.RemotePieces
	}
	return nil
}

type Pointer struct {
	Type           Pointer_DataType `protobuf:"varint,1,opt,name=type,proto3,enum=fastpb.Pointer_DataType" json:"type,omitempty"`
	InlineSegment  []byte           `protobuf:"bytes,3,opt,name=inline_segment,json=inlineSegment,proto3" json:"inline_segment,omitempty"`
	Remote         *RemoteSegment   `protobuf:"bytes,4,opt,name=remote,proto3" json:"remote,omitempty"`
	SegmentSize    int64            `protobuf:"varint,5,opt,name=segment_size,json=segmentSize,proto3" json:"segment_size,omitempty"`
	CreationDate   time.Time        `protobuf:"bytes,6,opt,name=creation_date,json=creationDate,proto3,stdtime" json:"creation_date"`
	ExpirationDate time.Time        `protobuf:"bytes,7,opt,name=expiration_date,json=expirationDate,proto3,stdtime" json:"expiration_date"`
	Metadata       []byte           `protobuf:"bytes,8,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *Pointer) Reset()         { *m = Pointer{} }
func (m *Pointer) String() string { return proto.CompactTextString(m) }
func (*Pointer) ProtoMessage()    {}
func (*Pointer) Descriptor() ([]byte, []int) {
	return fileDescriptor_75fef806d28fc810, []int{3}
}
func (m *Pointer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pointer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pointer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pointer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pointer.Merge(m, src)
}
func (m *Pointer) XXX_Size() int {
	return m.Size()
}
func (m *Pointer) XXX_DiscardUnknown() {
	xxx_messageInfo_Pointer.DiscardUnknown(m)
}

var xxx_messageInfo_Pointer proto.InternalMessageInfo

func (m *Pointer) GetType() Pointer_DataType {
	if m != nil {
		return m.Type
	}
	return Pointer_INLINE
}

func (m *Pointer) GetInlineSegment() []byte {
	if m != nil {
		return m.InlineSegment
	}
	return nil
}

func (m *Pointer) GetRemote() *RemoteSegment {
	if m != nil {
		return m.Remote
	}
	return nil
}

func (m *Pointer) GetSegmentSize() int64 {
	if m != nil {
		return m.SegmentSize
	}
	return 0
}

func (m *Pointer) GetCreationDate() time.Time {
	if m != nil {
		return m.CreationDate
	}
	return time.Time{}
}

func (m *Pointer) GetExpirationDate() time.Time {
	if m != nil {
		return m.ExpirationDate
	}
	return time.Time{}
}

func (m *Pointer) GetMetadata() []byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type SegmentMeta struct {
	EncryptedKey []byte `protobuf:"bytes,1,opt,name=encrypted_key,json=encryptedKey,proto3" json:"encrypted_key,omitempty"`
	KeyNonce     []byte `protobuf:"bytes,2,opt,name=key_nonce,json=keyNonce,proto3" json:"key_nonce,omitempty"`
}

func (m *SegmentMeta) Reset()         { *m = SegmentMeta{} }
func (m *SegmentMeta) String() string { return proto.CompactTextString(m) }
func (*SegmentMeta) ProtoMessage()    {}
func (*SegmentMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_75fef806d28fc810, []int{4}
}
func (m *SegmentMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SegmentMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SegmentMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SegmentMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegmentMeta.Merge(m, src)
}
func (m *SegmentMeta) XXX_Size() int {
	return m.Size()
}
func (m *SegmentMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_SegmentMeta.DiscardUnknown(m)
}

var xxx_messageInfo_SegmentMeta proto.InternalMessageInfo

func (m *SegmentMeta) GetEncryptedKey() []byte {
	if m != nil {
		return m.EncryptedKey
	}
	return nil
}

func (m *SegmentMeta) GetKeyNonce() []byte {
	if m != nil {
		return m.KeyNonce
	}
	return nil
}

type StreamInfo struct {
	DeprecatedNumberOfSegments int64  `protobuf:"varint,1,opt,name=deprecated_number_of_segments,json=deprecatedNumberOfSegments,proto3" json:"deprecated_number_of_segments,omitempty"`
	SegmentsSize               int64  `protobuf:"varint,2,opt,name=segments_size,json=segmentsSize,proto3" json:"segments_size,omitempty"`
	LastSegmentSize            int64  `protobuf:"varint,3,opt,name=last_segment_size,json=lastSegmentSize,proto3" json:"last_segment_size,omitempty"`
	Metadata                   []byte `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *StreamInfo) Reset()         { *m = StreamInfo{} }
func (m *StreamInfo) String() string { return proto.CompactTextString(m) }
func (*StreamInfo) ProtoMessage()    {}
func (*StreamInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_75fef806d28fc810, []int{5}
}
func (m *StreamInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamInfo.Merge(m, src)
}
func (m *StreamInfo) XXX_Size() int {
	return m.Size()
}
func (m *StreamInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamInfo.DiscardUnknown(m)
}

var xxx_messageInfo_StreamInfo proto.InternalMessageInfo

func (m *StreamInfo) GetDeprecatedNumberOfSegments() int64 {
	if m != nil {
		return m.DeprecatedNumberOfSegments
	}
	return 0
}

func (m *StreamInfo) GetSegmentsSize() int64 {
	if m != nil {
		return m.SegmentsSize
	}
	return 0
}

func (m *StreamInfo) GetLastSegmentSize() int64 {
	if m != nil {
		return m.LastSegmentSize
	}
	return 0
}

func (m *StreamInfo) GetMetadata() []byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type StreamMeta struct {
	EncryptedStreamInfo []byte       `protobuf:"bytes,1,opt,name=encrypted_stream_info,json=encryptedStreamInfo,proto3" json:"encrypted_stream_info,omitempty"`
	EncryptionType      int32        `protobuf:"varint,2,opt,name=encryption_type,json=encryptionType,proto3" json:"encryption_type,omitempty"`
	EncryptionBlockSize int32        `protobuf:"varint,3,opt,name=encryption_block_size,json=encryptionBlockSize,proto3" json:"encryption_block_size,omitempty"`
	LastSegmentMeta     *SegmentMeta `protobuf:"bytes,4,opt,name=last_segment_meta,json=lastSegmentMeta,proto3" json:"last_segment_meta,omitempty"`
	NumberOfSegments    int64        `protobuf:"varint,5,opt,name=number_of_segments,json=numberOfSegments,proto3" json:"number_of_segments,omitempty"`
}

func (m *StreamMeta) Reset()         { *m = StreamMeta{} }
func (m *StreamMeta) String() string { return proto.CompactTextString(m) }
func (*StreamMeta) ProtoMessage()    {}
func (*StreamMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_75fef806d28fc810, []int{6}
}
func (m *StreamMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamMeta.Merge(m, src)
}
func (m *StreamMeta) XXX_Size() int {
	return m.Size()
}
func (m *StreamMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamMeta.DiscardUnknown(m)
}

var xxx_messageInfo_StreamMeta proto.InternalMessageInfo

func (m *StreamMeta) GetEncryptedStreamInfo() []byte {
	if m != nil {
		return m.EncryptedStreamInfo
	}
	return nil
}

func (m *StreamMeta) GetEncryptionType() int32 {
	if m != nil {
		return m.EncryptionType
	}
	return 0
}

func (m *StreamMeta) GetEncryptionBlockSize() int32 {
	if m != nil {
		return m.EncryptionBlockSize
	}
	return 0
}

func (m *StreamMeta) GetLastSegmentMeta() *SegmentMeta {
	if m != nil {
		return m.LastSegmentMeta
	}
	return nil
}

func (m *StreamMeta) GetNumberOfSegments() int64 {
	if m != nil {
		return m.NumberOfSegments
	}
	return 0
}

func init() {
	proto.RegisterEnum("fastpb.RedundancyScheme_SchemeType", RedundancyScheme_SchemeType_name, RedundancyScheme_SchemeType_value)
	proto.RegisterEnum("fastpb.Pointer_DataType", Pointer_DataType_name, Pointer_DataType_value)
	proto.RegisterType((*RedundancyScheme)(nil), "fastpb.RedundancyScheme")
	proto.RegisterType((*RemotePiece)(nil), "fastpb.RemotePiece")
	proto.RegisterType((*RemoteSegment)(nil), "fastpb.RemoteSegment")
	proto.RegisterType((*Pointer)(nil), "fastpb.Pointer")
	proto.RegisterType((*SegmentMeta)(nil), "fastpb.SegmentMeta")
	proto.RegisterType((*StreamInfo)(nil), "fastpb.StreamInfo")
	proto.RegisterType((*StreamMeta)(nil), "fastpb.StreamMeta")
}

func init() { proto.RegisterFile("pointerdb.proto", fileDescriptor_75fef806d28fc810) }

var fileDescriptor_75fef806d28fc810 = []byte{
	// 843 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x4d, 0x6f, 0x1b, 0x45,
	0x18, 0xf6, 0xc6, 0xf1, 0x07, 0xaf, 0x3f, 0x3b, 0xa5, 0xc2, 0x32, 0xc2, 0x49, 0xb7, 0x42, 0x0d,
	0x10, 0x5c, 0xc9, 0x3d, 0xc0, 0x09, 0x54, 0xcb, 0x39, 0xac, 0x68, 0x9c, 0x6a, 0x1c, 0x71, 0x5d,
	0x8d, 0x77, 0x5f, 0x3b, 0xab, 0x78, 0x67, 0xb6, 0xb3, 0x63, 0x09, 0xf7, 0x27, 0x20, 0x0e, 0xfd,
	0x0f, 0xfc, 0x0d, 0xc4, 0xb9, 0xc7, 0x1e, 0x11, 0x87, 0x82, 0x92, 0x3f, 0x82, 0x66, 0x66, 0x3f,
	0x9c, 0x08, 0x0e, 0x5c, 0x92, 0x9d, 0xf7, 0x7d, 0xe6, 0xfd, 0x78, 0x9e, 0x67, 0x0c, 0xbd, 0x44,
	0x44, 0x5c, 0xa1, 0x0c, 0x97, 0xe3, 0x44, 0x0a, 0x25, 0x48, 0x7d, 0xc5, 0x52, 0x95, 0x2c, 0x87,
	0x47, 0x6b, 0x21, 0xd6, 0x1b, 0x7c, 0x66, 0xa2, 0xcb, 0xed, 0xea, 0x99, 0x8a, 0x62, 0x4c, 0x15,
	0x8b, 0x13, 0x0b, 0x1c, 0xc2, 0x5a, 0xac, 0x85, 0xfd, 0x76, 0x7f, 0x3d, 0x80, 0x3e, 0xc5, 0x70,
	0xcb, 0x43, 0xc6, 0x83, 0xdd, 0x22, 0xb8, 0xc2, 0x18, 0xc9, 0x37, 0x70, 0xa8, 0x76, 0x09, 0x0e,
	0x9c, 0x63, 0xe7, 0xa4, 0x3b, 0x79, 0x32, 0xb6, 0x85, 0xc7, 0xf7, 0x71, 0x63, 0xfb, 0xef, 0x72,
	0x97, 0x20, 0x35, 0x17, 0xc8, 0x27, 0xd0, 0x88, 0x23, 0xee, 0x4b, 0x7c, 0x3d, 0x38, 0x38, 0x76,
	0x4e, 0x6a, 0xb4, 0x1e, 0x47, 0x9c, 0xe2, 0x6b, 0xf2, 0x31, 0xd4, 0x94, 0x50, 0x6c, 0x33, 0xa8,
	0x9a, 0xb0, 0x3d, 0x90, 0x2f, 0xa0, 0x2f, 0x31, 0x61, 0x91, 0xf4, 0xd5, 0x95, 0xc4, 0xf4, 0x4a,
	0x6c, 0xc2, 0xc1, 0xa1, 0x01, 0xf4, 0x6c, 0xfc, 0x32, 0x0f, 0x93, 0xaf, 0xe0, 0x41, 0xba, 0x0d,
	0x02, 0x4c, 0xd3, 0x3d, 0x6c, 0xcd, 0x60, 0xfb, 0x59, 0xa2, 0x04, 0x9f, 0x02, 0x41, 0xc9, 0xd2,
	0xad, 0x44, 0x3f, 0xbd, 0x62, 0xfa, 0x6f, 0xf4, 0x06, 0x07, 0x75, 0x8b, 0xce, 0x32, 0x0b, 0x9d,
	0x58, 0x44, 0x6f, 0xd0, 0x7d, 0x0c, 0x50, 0x2e, 0x42, 0x5a, 0xd0, 0xf0, 0xe6, 0x3f, 0xbe, 0x78,
	0xe9, 0xcd, 0xfa, 0x15, 0x52, 0x87, 0x03, 0xba, 0xe8, 0x3b, 0xee, 0x02, 0x5a, 0x14, 0x63, 0xa1,
	0xf0, 0x55, 0x84, 0x01, 0x92, 0x4f, 0xe1, 0xa3, 0x44, 0x7f, 0xf8, 0x7c, 0x1b, 0x1b, 0x92, 0x6a,
	0xb4, 0x69, 0x02, 0xf3, 0x6d, 0x4c, 0x9e, 0x42, 0x83, 0x8b, 0x10, 0xfd, 0x28, 0x34, 0x1c, 0xb4,
	0xa7, 0xdd, 0x77, 0x1f, 0x8e, 0x2a, 0x7f, 0x7e, 0x38, 0xaa, 0xcf, 0x45, 0x88, 0xde, 0x8c, 0xd6,
	0x75, 0xda, 0x0b, 0xdd, 0xdf, 0x1d, 0xe8, 0xd8, 0xaa, 0x0b, 0x5c, 0xc7, 0xc8, 0x15, 0xf9, 0x16,
	0x40, 0x16, 0x1c, 0x9b, 0xc2, 0xad, 0xc9, 0xe0, 0xbf, 0xd8, 0xa7, 0x7b, 0x58, 0xf2, 0x1c, 0x3a,
	0x52, 0x08, 0xe5, 0xdb, 0xb1, 0x8a, 0xd6, 0xbd, 0xac, 0x75, 0xc3, 0xcc, 0xed, 0xcd, 0x68, 0x4b,
	0xa3, 0xec, 0x21, 0x24, 0xdf, 0x41, 0x47, 0x9a, 0xfe, 0xf6, 0x5a, 0x3a, 0xa8, 0x1e, 0x57, 0x4f,
	0x5a, 0x93, 0x87, 0x65, 0xc7, 0x62, 0xe5, 0xe9, 0xa1, 0xae, 0x44, 0xdb, 0xb2, 0x0c, 0xa5, 0xee,
	0xcf, 0x55, 0x68, 0xbc, 0xb2, 0x26, 0x24, 0xa7, 0x77, 0x2c, 0x53, 0x0c, 0x9d, 0xa5, 0xc7, 0x33,
	0xa6, 0xd8, 0x9e, 0x4f, 0x3e, 0x87, 0x6e, 0xc4, 0x37, 0x11, 0x47, 0x3f, 0xb5, 0xab, 0x1b, 0x5f,
	0xb4, 0x69, 0xc7, 0x46, 0x73, 0x3e, 0xbe, 0x86, 0xba, 0x6d, 0x68, 0x5c, 0xd1, 0x9a, 0x3c, 0xba,
	0x3b, 0x59, 0x06, 0xa3, 0x19, 0x88, 0x3c, 0x86, 0x76, 0x56, 0xce, 0x0a, 0xae, 0xed, 0x51, 0xa5,
	0xad, 0x2c, 0xa6, 0xb5, 0x26, 0x1e, 0x74, 0x02, 0x89, 0x4c, 0x45, 0x82, 0xfb, 0x21, 0x53, 0xd6,
	0x14, 0xad, 0xc9, 0x70, 0x6c, 0xdf, 0xcc, 0x38, 0x7f, 0x33, 0xe3, 0xcb, 0xfc, 0xcd, 0x4c, 0x9b,
	0x7a, 0xf3, 0xb7, 0x7f, 0x1d, 0x39, 0xb4, 0x9d, 0x5f, 0x9d, 0x31, 0x85, 0xe4, 0x1c, 0x7a, 0xf8,
	0x53, 0x12, 0xc9, 0xbd, 0x62, 0x8d, 0xff, 0x51, 0xac, 0x5b, 0x5e, 0x36, 0xe5, 0x86, 0xd0, 0x8c,
	0x51, 0xb1, 0x90, 0x29, 0x36, 0x68, 0x1a, 0x32, 0x8a, 0xb3, 0xeb, 0x42, 0x33, 0x27, 0x90, 0x00,
	0xd4, 0xbd, 0xf9, 0x4b, 0x6f, 0x7e, 0xd6, 0xaf, 0xe8, 0x6f, 0x7a, 0x76, 0x7e, 0x71, 0x79, 0xd6,
	0x77, 0xdc, 0x0b, 0x68, 0x65, 0x7c, 0x9c, 0xa3, 0x62, 0xe4, 0x09, 0x74, 0x90, 0x07, 0x72, 0x97,
	0x28, 0x0c, 0xfd, 0x6b, 0xb4, 0x6e, 0x6a, 0xd3, 0x76, 0x11, 0xfc, 0x01, 0x77, 0xda, 0xc7, 0xd7,
	0xb8, 0xf3, 0xb9, 0xe0, 0x01, 0x5a, 0xc7, 0xd0, 0xe6, 0x35, 0xee, 0xe6, 0xfa, 0xec, 0xfe, 0xe6,
	0x00, 0x2c, 0x94, 0x44, 0x16, 0x7b, 0x7c, 0x25, 0xc8, 0x0b, 0xf8, 0x2c, 0xc4, 0x44, 0x62, 0xc0,
	0x74, 0x45, 0xbe, 0x8d, 0x97, 0x28, 0x7d, 0xb1, 0xca, 0x05, 0x4c, 0x4d, 0x83, 0x2a, 0x1d, 0x96,
	0xa0, 0xb9, 0xc1, 0x5c, 0xac, 0xb2, 0xb1, 0x52, 0x3d, 0x53, 0x8e, 0xb6, 0x02, 0x1d, 0x98, 0x2b,
	0xb9, 0x68, 0xa9, 0x51, 0xe8, 0x4b, 0x78, 0xb0, 0x61, 0xa9, 0xf2, 0xef, 0x28, 0x59, 0x35, 0xc0,
	0x9e, 0x4e, 0x2c, 0xf6, 0xd4, 0xdc, 0xe7, 0xec, 0xf0, 0x1e, 0x67, 0xbf, 0x1c, 0xe4, 0xe3, 0x1b,
	0x3e, 0x26, 0xf0, 0xa8, 0xe4, 0x23, 0x35, 0x71, 0x3f, 0xe2, 0x2b, 0x91, 0xf1, 0xf2, 0xb0, 0x48,
	0xee, 0xad, 0xfc, 0x14, 0x7a, 0x59, 0x58, 0x2b, 0x6c, 0xec, 0x6d, 0x7f, 0xd5, 0xba, 0x65, 0xd8,
	0x68, 0x52, 0x16, 0xd7, 0xc0, 0xe5, 0x46, 0x04, 0xd7, 0xe5, 0xdc, 0xb5, 0xa2, 0x78, 0x24, 0xf8,
	0x54, 0xe7, 0xcc, 0xec, 0xdf, 0xdf, 0xdb, 0x53, 0x0f, 0x9e, 0xd9, 0xbc, 0x78, 0x80, 0x7b, 0x82,
	0xde, 0x59, 0xde, 0x6c, 0x74, 0x0a, 0xe4, 0x5f, 0x54, 0xb0, 0x9e, 0xef, 0xf3, 0x7b, 0xdc, 0x4f,
	0x07, 0xef, 0x6e, 0x46, 0xce, 0xfb, 0x9b, 0x91, 0xf3, 0xf7, 0xcd, 0xc8, 0x79, 0x7b, 0x3b, 0xaa,
	0xbc, 0xbf, 0x1d, 0x55, 0xfe, 0xb8, 0x1d, 0x55, 0x96, 0x75, 0x63, 0xd3, 0xe7, 0xff, 0x04, 0x00,
	0x00, 0xff, 0xff, 0xd3, 0xcd, 0x4c, 0x1c, 0x50, 0x06, 0x00, 0x00,
}

func (m *RedundancyScheme) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedundancyScheme) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedundancyScheme) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ErasureShareSize != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.ErasureShareSize))
		i--
		dAtA[i] = 0x30
	}
	if m.SuccessThreshold != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.SuccessThreshold))
		i--
		dAtA[i] = 0x28
	}
	if m.RepairThreshold != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.RepairThreshold))
		i--
		dAtA[i] = 0x20
	}
	if m.Total != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if m.MinReq != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.MinReq))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemotePiece) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemotePiece) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemotePiece) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NodeId.Size()
		i -= size
		if _, err := m.NodeId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPointerdb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PieceNum != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.PieceNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoteSegment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemotePieces) > 0 {
		for iNdEx := len(m.RemotePieces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RemotePieces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPointerdb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.RootPieceId.Size()
		i -= size
		if _, err := m.RootPieceId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPointerdb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Redundancy != nil {
		{
			size, err := m.Redundancy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPointerdb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pointer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pointer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pointer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintPointerdb(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x42
	}
	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ExpirationDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ExpirationDate):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintPointerdb(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x3a
	n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreationDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreationDate):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintPointerdb(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x32
	if m.SegmentSize != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.SegmentSize))
		i--
		dAtA[i] = 0x28
	}
	if m.Remote != nil {
		{
			size, err := m.Remote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPointerdb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.InlineSegment) > 0 {
		i -= len(m.InlineSegment)
		copy(dAtA[i:], m.InlineSegment)
		i = encodeVarintPointerdb(dAtA, i, uint64(len(m.InlineSegment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SegmentMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegmentMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SegmentMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyNonce) > 0 {
		i -= len(m.KeyNonce)
		copy(dAtA[i:], m.KeyNonce)
		i = encodeVarintPointerdb(dAtA, i, uint64(len(m.KeyNonce)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EncryptedKey) > 0 {
		i -= len(m.EncryptedKey)
		copy(dAtA[i:], m.EncryptedKey)
		i = encodeVarintPointerdb(dAtA, i, uint64(len(m.EncryptedKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintPointerdb(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x22
	}
	if m.LastSegmentSize != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.LastSegmentSize))
		i--
		dAtA[i] = 0x18
	}
	if m.SegmentsSize != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.SegmentsSize))
		i--
		dAtA[i] = 0x10
	}
	if m.DeprecatedNumberOfSegments != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.DeprecatedNumberOfSegments))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StreamMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumberOfSegments != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.NumberOfSegments))
		i--
		dAtA[i] = 0x28
	}
	if m.LastSegmentMeta != nil {
		{
			size, err := m.LastSegmentMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPointerdb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.EncryptionBlockSize != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.EncryptionBlockSize))
		i--
		dAtA[i] = 0x18
	}
	if m.EncryptionType != 0 {
		i = encodeVarintPointerdb(dAtA, i, uint64(m.EncryptionType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.EncryptedStreamInfo) > 0 {
		i -= len(m.EncryptedStreamInfo)
		copy(dAtA[i:], m.EncryptedStreamInfo)
		i = encodeVarintPointerdb(dAtA, i, uint64(len(m.EncryptedStreamInfo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPointerdb(dAtA []byte, offset int, v uint64) int {
	offset -= sovPointerdb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RedundancyScheme) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPointerdb(uint64(m.Type))
	}
	if m.MinReq != 0 {
		n += 1 + sovPointerdb(uint64(m.MinReq))
	}
	if m.Total != 0 {
		n += 1 + sovPointerdb(uint64(m.Total))
	}
	if m.RepairThreshold != 0 {
		n += 1 + sovPointerdb(uint64(m.RepairThreshold))
	}
	if m.SuccessThreshold != 0 {
		n += 1 + sovPointerdb(uint64(m.SuccessThreshold))
	}
	if m.ErasureShareSize != 0 {
		n += 1 + sovPointerdb(uint64(m.ErasureShareSize))
	}
	return n
}

func (m *RemotePiece) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PieceNum != 0 {
		n += 1 + sovPointerdb(uint64(m.PieceNum))
	}
	l = m.NodeId.Size()
	n += 1 + l + sovPointerdb(uint64(l))
	return n
}

func (m *RemoteSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Redundancy != nil {
		l = m.Redundancy.Size()
		n += 1 + l + sovPointerdb(uint64(l))
	}
	l = m.RootPieceId.Size()
	n += 1 + l + sovPointerdb(uint64(l))
	if len(m.RemotePieces) > 0 {
		for _, e := range m.RemotePieces {
			l = e.Size()
			n += 1 + l + sovPointerdb(uint64(l))
		}
	}
	return n
}

func (m *Pointer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPointerdb(uint64(m.Type))
	}
	l = len(m.InlineSegment)
	if l > 0 {
		n += 1 + l + sovPointerdb(uint64(l))
	}
	if m.Remote != nil {
		l = m.Remote.Size()
		n += 1 + l + sovPointerdb(uint64(l))
	}
	if m.SegmentSize != 0 {
		n += 1 + sovPointerdb(uint64(m.SegmentSize))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreationDate)
	n += 1 + l + sovPointerdb(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.ExpirationDate)
	n += 1 + l + sovPointerdb(uint64(l))
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovPointerdb(uint64(l))
	}
	return n
}

func (m *SegmentMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptedKey)
	if l > 0 {
		n += 1 + l + sovPointerdb(uint64(l))
	}
	l = len(m.KeyNonce)
	if l > 0 {
		n += 1 + l + sovPointerdb(uint64(l))
	}
	return n
}

func (m *StreamInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeprecatedNumberOfSegments != 0 {
		n += 1 + sovPointerdb(uint64(m.DeprecatedNumberOfSegments))
	}
	if m.SegmentsSize != 0 {
		n += 1 + sovPointerdb(uint64(m.SegmentsSize))
	}
	if m.LastSegmentSize != 0 {
		n += 1 + sovPointerdb(uint64(m.LastSegmentSize))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovPointerdb(uint64(l))
	}
	return n
}

func (m *StreamMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptedStreamInfo)
	if l > 0 {
		n += 1 + l + sovPointerdb(uint64(l))
	}
	if m.EncryptionType != 0 {
		n += 1 + sovPointerdb(uint64(m.EncryptionType))
	}
	if m.EncryptionBlockSize != 0 {
		n += 1 + sovPointerdb(uint64(m.EncryptionBlockSize))
	}
	if m.LastSegmentMeta != nil {
		l = m.LastSegmentMeta.Size()
		n += 1 + l + sovPointerdb(uint64(l))
	}
	if m.NumberOfSegments != 0 {
		n += 1 + sovPointerdb(uint64(m.NumberOfSegments))
	}
	return n
}

func sovPointerdb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPointerdb(x uint64) (n int) {
	return sovPointerdb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RedundancyScheme) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPointerdb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedundancyScheme: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedundancyScheme: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= RedundancyScheme_SchemeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinReq", wireType)
			}
			m.MinReq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinReq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairThreshold", wireType)
			}
			m.RepairThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepairThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessThreshold", wireType)
			}
			m.SuccessThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErasureShareSize", wireType)
			}
			m.ErasureShareSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErasureShareSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPointerdb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPointerdb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPointerdb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemotePiece) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPointerdb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemotePiece: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemotePiece: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PieceNum", wireType)
			}
			m.PieceNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PieceNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPointerdb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPointerdb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NodeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPointerdb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPointerdb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPointerdb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteSegment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPointerdb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteSegment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteSegment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redundancy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPointerdb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPointerdb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Redundancy == nil {
				m.Redundancy = &RedundancyScheme{}
			}
			if err := m.Redundancy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootPieceId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPointerdb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPointerdb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RootPieceId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePieces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPointerdb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPointerdb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemotePieces = append(m.RemotePieces, RemotePiece{})
			if err := m.RemotePieces[len(m.RemotePieces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPointerdb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPointerdb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPointerdb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pointer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPointerdb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pointer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pointer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Pointer_DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineSegment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPointerdb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPointerdb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineSegment = append(m.InlineSegment[:0], dAtA[iNdEx:postIndex]...)
			if m.InlineSegment == nil {
				m.InlineSegment = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPointerdb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPointerdb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Remote == nil {
				m.Remote = &RemoteSegment{}
			}
			if err := m.Remote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentSize", wireType)
			}
			m.SegmentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPointerdb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPointerdb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreationDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPointerdb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPointerdb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.ExpirationDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPointerdb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPointerdb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPointerdb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPointerdb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPointerdb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegmentMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPointerdb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegmentMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegmentMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPointerdb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPointerdb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedKey = append(m.EncryptedKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedKey == nil {
				m.EncryptedKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPointerdb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPointerdb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyNonce = append(m.KeyNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyNonce == nil {
				m.KeyNonce = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPointerdb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPointerdb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPointerdb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPointerdb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedNumberOfSegments", wireType)
			}
			m.DeprecatedNumberOfSegments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedNumberOfSegments |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentsSize", wireType)
			}
			m.SegmentsSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentsSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSegmentSize", wireType)
			}
			m.LastSegmentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSegmentSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPointerdb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPointerdb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPointerdb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPointerdb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPointerdb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPointerdb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedStreamInfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPointerdb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPointerdb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedStreamInfo = append(m.EncryptedStreamInfo[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedStreamInfo == nil {
				m.EncryptedStreamInfo = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionType", wireType)
			}
			m.EncryptionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncryptionType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionBlockSize", wireType)
			}
			m.EncryptionBlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncryptionBlockSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSegmentMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPointerdb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPointerdb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSegmentMeta == nil {
				m.LastSegmentMeta = &SegmentMeta{}
			}
			if err := m.LastSegmentMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfSegments", wireType)
			}
			m.NumberOfSegments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfSegments |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPointerdb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPointerdb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPointerdb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPointerdb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPointerdb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPointerdb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPointerdb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPointerdb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPointerdb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPointerdb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPointerdb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPointerdb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPointerdb   = fmt.Errorf("proto: integer overflow")
)
